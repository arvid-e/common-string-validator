# Namngivning
| Namn | Förklaring | Reflektion och regler från Clean Code |
|---|---|---|
| DateValidator |  Klass ansvarig för att validera datum strängar i de vanligaste formaten. | **Class names:** Namn på klasser ska vara substantiv, inte verb. Då min modul är till för att validera olika typer av strängar har jag varit konsekvent i namngivningen av klasserna i modulen, t.ex DateValidator, EmailValidator etc. |
| isValidEmail(email: string) | Metod som validerar en Email sträng | **Method Names:** Eftersom metoden börjar med “is” så kan man förstå att metoden kommer att returnera ett booleskt värde. Jag har valt att namnge alla de publika metoderna på liknande sätt, som t.ex isValidDate() och isValidPassword().  |
| emailIsValid | Konstant av booleskt värde som isValidEmail() returnerar | När en metod eller funktion returnerar ett booleskt värde så, som rekommenderas i boken, rimligtvis namnge metoden till något som börjar med “is”, som jag har gjort med isValidEmail() etc. Men ett problem uppstod när jag sedan skulle namnge konstanten som ska hålla det booleska värdet och som sedan ska returneras.  Den konstanten skulle också kunna namnges isValidEmail, lika som namnet för metoden. Frågan är då alltså om man bör undvika att ha samma namn på en konstant i en metod som själva metoden? Eller om uppståndelsen av detta problem betyder att en ny konstant inte ens behövs, eller till och med bör undvikas? Detta problemet är inte nämnt i boken, och personligen brukar jag tycka det är tydligare och lättare att förstå koden genom att skapa nya konstanter eller variabler som beskriver vad som utförs, så för att komma runt problemet valda jag helt enkelt att vända på orden lite, och namnge konstanten till emailIsValid. Problemet skulle också kunna undvikas helt genom att returnera uttrycket direkt, istället för att först definiera en konstant som sedan returneras. Funderar över om när konstanten kan ha samma namn som metoden den finns i, koden är simpel och det redan är uppenbart vad som utförs från namnet av metoden så kanske det inte är någon poäng med att skapa någon konstant, och istället returnera uttrycket direkt. Skulle gärna vilja höra åsikter om detta, då detta problem återkom vid flera metoder. |
| hasValidLength(password: string) och containsNumber(password: string) | Metoder som används i PasswordValidator klassen. Används för att se till  att en lösenord sträng är tillräckligt lång och att den innehåller ett nummer.| **Pick One Word per Concept:** Det finns ofta flera sätt att uttrycka samma sak, och för att koden man skrivit inte ska vara förvirrande för andra så är det bra att hålla sig till ett ord per koncept. Efter jag läste detta i boken märkte jag sedan i min kod att jag hade i min PasswordValidor, en metod med namnet hasValidLength, men de andra metoderna hade namn som började med “contains”, som i containsNumber(). Detta skulle kunna orsaka förvirring. **Use Intent-Revealing Names:** Duktiga programmerare spenderar tid på att välja namn som har betydelse och är beskrivande. När man som programmerare läser namn på variabler och funktioner på kod någon annan skrivit så letar man efter betydelsen bakom namnen för att förstå vad den funktionen är variabeln är till för. Man försöker förstå hur den som skrivit koden har tänkt. Om det då finns metoden hasValidLength och containsNumber kan man ifrågasätta om det är någon skillnad i hur metoderna fungerar. “Personen som skrivit koden har valt olika namn, så det måste vara någon skillnad i hur metoderna fungerar. Varför har annars personen som skrivit koden valt att ha olika namn?” För att undvika att frågan kan uppstå så borde jag vara konsekvent i min namngivning och byta namn till hasValidLength och hålla mig till “has” i nya metoder som också validerar innehållet en sträng. Att ha vara konsekvent i sin namngivning underlättar det även när man använder sig av autocomplete funktionen i sin IDE, där om man är konsekvent med sig namngivning snabbt får upp en grupperad lista av förslag på de metoder som är av samma sort eller är relaterade till varandra på någon sätt. |
| extractAndValidateUrl(urlString: string, urlRegex: Regex) | Metod till för att hämta data från en Regex sträng och validera den | **Use Intent Revealing Names:** "If a name requires a comment, then the name does not reveal its intent." För att göra den här metoden så tydlig som möjligt tog jag hänsyn för ordningen av parametrarna, först extract sedan validate. Så man bör kunna förstå att URL strängen ska vara först, sedan Regex strängen som ska utföra valideringen. **Add Meaningful Context:** För att göra skillnaden mellan URL strängen och Regex strängen uppenbar så lade jag till String och Regex i slutet av respektive parameternamn. Tyckte först att det inte skulle behövas eftersom deras typ är redan definerade redan, men det var svårt att komma bra på namn som gör skillnaden mellan dom tydligt så tycker urlString och urlRegex passar bra.  |


## Kapitelreflektion - Kapitel 2
Jag lärde mig mycket nya bra tips och riktilinjer om hur man bör namnge sina klasser, metoder, konstanter etc. Det som jag tagit med mig är att inte vara rädd för att ge längre namn om det behövs. Även att hålla sig till samma namn för varje sorts operation man utför, i mitt fall hålla mig till **has**Number, **has**SpecialCharacter etc, istället för att blanda in **contains**UpperCaseLetter. Som jag nämnde i tabellen ovan så tänker de som läser din kod att det finns en mening eller betydelse till namnen man ger. Så om en metod börjar med **has** och en annan med **contains** så är det lätt att tro att det finns någonting fundamell skillnad mellan metoderna. Lärde mig också att man kan ta hjälp av metodnamnet för att göra det uppenbart vilken ordning som argumenten ska vara, vilket gör det lättare att göra rätt för den som använder metoden.

Som jag nämnde ovan i tabellet så är jag lite osäker på namngivningen av konstanten som en funktion returnerar. Om konstanen kan ha exact samma namn som metoden, betyder det att den inte behövs, att jag definerat något tokigt eller är det normalt? Det är något som inte nämndes i boken.



# Funktioner
| Method | Kod | Antal rader | Reflektion |
|---|---|---| --- |
| isValidLongDate(date: string) | link | 16 | **Do One Thing:** En funktion ska endast göra en sak. Det var lite svårt att komma till underfund med vad "en sak" är. På grund av att String.match() i sig själv gör mer än en sak så var det svårt att veta hur mycket som jag behöver dela upp i flera metoder. Skulle nog kunnat haft en metod som bara gör String.match() och returnerar den matchade strängen. |
| hasValidYearMonthDay(year: number, month: number, day: number) | link | 15 | **Function Arguments:**  En funktion bör ha så få argument som möjligt, eftersom komplexiteten av funktionen ökar exponentiellt med varje extra argument som läggs till. Den här metoden har tre argument, vilket inte är optimalt. För att göra det lättare att förstå i vilken ordning så är namnet av metoden i ordning av argumenten från vänster till höger, vilket undviker argument på fel plats till en viss grad. Eftersom år, månad och dagens datum behövs för att skapa ett datum så kunde jag inte komma undan tre argument. Om jag inte istället skulle ta ett object som parameter som måste innehålla år, månad och dagens datum. Osäker på om det är en bättre lösning eller inte. |
| extractAndValidateUrl(urlString: string, urlRegex: RegExp) | link | 5 | **Command Query Separation:** Det här kapitlet nämner att en funktion ska antingen göra någonting eller hämta information ifrån någonting. Det blev ett problem men metoder som gör Regex validationen. Den här metoden hämtar data från en Regex sträng och validerar det. Det är något som boken säger att man ska undvika. I det här fallet kunde jag inte undvika det på grund av att String.match() gör både och. Den validerar så att Regex strängen matchar och hämtar data från Regex strängen som sedan används för ytterligare validering.  |
| contructUrlRegex() | link | 24 | **Function Arguments:** Man bör ha så få argument som möjligt. I den här metoden var det möjligt att inte ha något argument, vilket är det man ska sträva efter enligt boken. Anledningen för att denna metod är lite längre är att jag delade upp Regex strängen i delan för att lättare kunna förstå vad Regex strängen gör. Gjorde det för Email Regex strängen och URL Regex strängen eftersom de blev långa och svåra att förstå. **Do One Thing:** De här metoderna är det väldigt tydligt att de gör endast en sak: skapa Regex strängen.|
| isValidShortDate(date: string) | link | 15 | **Do One Thing:** Lika som i de andra metoderna för att validera olika sorters av datum strängar så undrade jag om ansvaret för metoderna är lite för stort och att de faktiskt gör flera saker, och skapade därför hasValidYearMonthDay metoden. **Don't Repeat Yourself:** Genom att skapa metoden hasValidYearMonthDay så behövde jag inte längre upprepa samma datumvalideringskod i alla sorters datum valideringsmetoder.

## Kapitelreflektion - Kapitel 3

Lärde mig mycket nytt om hur funktioner ska defineras och vad man bör undvika. Visste sedan tidigare att man ska försöka göra så att en funktion endast gör en sak och inte ska vara för stora, men har lärt mig nu att funktioner ska vara ännu mer fokuserade på en sak och ännu mindre än vad jag trodde. Att dela upp funktioner till mycket mindre funktioner som faktiskt bara gör en sak bidrar till kod som är lättare att förstå och underhålla. Något som gjorde det svårt att följa att en funktion endast ska göra en sak var användadet av Regex strängas för validering. Problemet är, som jag nämnde ovan i tabellen, att String.match() gör två saker. Det validerar en Regex sträng och hämtar data från strängen för ytterligare validering. Om jag kunde hade jag velat dela upp så att en funktion validerar och en annan hämtar den validerade datan som sedan används av andra valideringfunktioner. 

Något jag inte hade tänkt mycket på innan, som jag lärde mig nu, är att man ska försöka ha så få argument som möjligt på en funktion. Eftersom med flera argument så ökar antalet olika möjliga utfall exponentialt och gör det mycket svårare att testa för varje utfall. Som jag nämnde tidigare så lärde jag mig även att om man måste ha flera argument till sin funktion så kan man namngiva funkntion på så sätt att det går att förstå i vilken ordningen argumenten är tänkt att vara.

Sammanfattat så har jag fått ett mycket bättre grepp på hur man bör definera sina funktioner, hur man ska bestämma ett bra namn för funktionen och vilket ansvar funktionen ska ha.

## Kodkvalitet reflektion
Jag läste boken i mellan jag kodade och kände att ju längre jag kom i boken ju mer ändrade jag min kod för att bättre följa riktilinjerna som framfördes. Det är svårt att säga om min kod är lätt att förstå, eftersom det är jag som skrivit den, men jag tycker endå att det borde gå bra att följa hur jag tänkt genom min namngivning av konstanter och metoder samt min fördelning av ansvar och användning av JSDoc kommentarer. Jag kan dock se områden där det går att förbättra och om någon annan skulle läsa och försöka förstå min kod skulle de säkerligen hitta ännu fler områden för förbättring som jag inte hittade.

För övrigt tyckte jag det var ganska roligt att försöka hitta funktionen i funktioner, alltså fördela ansvaret av olika områden till olika funktioner som endast gör en sak.